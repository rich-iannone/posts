---
title: "The Prolific Output of Wes McKinney in the Age of Agentic Engineering"
author: "Rich Iannone"
date: "2026-02-16"
description: >
  A look at the recent open source projects of Wes McKinney, who has been shipping
  at great velocity by pairing his deep engineering experience with AI coding agents.
---

Wes McKinney is best known as the creator of [pandas](https://pandas.pydata.org/), the Python library that transformed data analysis. He's also behind [Apache Arrow](https://arrow.apache.org/) and [Ibis](https://ibis-project.org/), and has written *[Python for Data Analysis](https://wesmckinney.com/book)*. In short, Wes has already accomplished enough for several lifetimes of distinguished work. But the most interesting chapter of his career may be unfolding right now.

I've been watching it happen in real time. I work in open source at Posit, creating and maintaining R and Python packages. Wes and I aren't in the same group (he's working on Positron, the Data Science IDE by Posit) but I've been watching with amazement as his output has accelerated over the past few months. Given the rapid improvements in AI coding agents, these tools that are changing how even the most accomplished programmers approach building software. Wes's response has been to embrace these workflows fully, and the results are pretty incredible.

This post is my attempt to share what I've observed, and what I think readers, especially those curious about AI coding workflows, can learn from his journey. By looking at Wes's:

- embrace of AI coding agents
- five projects he shipped in rapid succession
- usage of previously unfamiliar-to-him languages

I'll share three big lessons I've taken away for my own work.

## Two Claude Max Accounts and an Astonishing Pace

Wes has been quite open about his current working methods, and they are worth looking into in some detail. He has been running two Claude Max subscriptions simultaneously, which allows him to keep multiple AI coding agents working in parallel. The reasoning is practical: while one agent is occupied with a task in one project, he can direct the other to begin work on something else entirely. It also helps with usage limits, since each subscription has per-period token quotas that heavy users can burn through quickly. The result is a kind of continuous pipeline of productive output, where the bottleneck is no longer the speed at which code can be written but rather the speed at which Wes can conceive of, direct, and review the work being done.

This arrangement has allowed him to produce an extraordinary volume of high-quality software in a very short span of time. He has described himself as working harder and having more fun building than he has had in years, and the evidence for that claim is clearly visible in his public repositories. The pace of commits, releases, and new project announcements has been something to behold. Let's take a closer look at what he has actually shipped...

### First Steps: moneyflow for Personal Finance in the Terminal

![The moneyflow TUI showing a keyboard-driven interface for exploring personal finance transactions.](images/moneyflow-tui.svg){fig-alt="moneyflow terminal UI displaying personal finance transactions with merchant names, categories, and amounts"}

[moneyflow](https://moneyflow.dev/) ([GitHub](https://github.com/wesm/moneyflow)) is a terminal-based personal finance tool written in Python that supports platforms like Monarch Money, YNAB, and Amazon purchase history. It is designed for people who prefer keyboard-driven workflows and need to process large numbers of transactions quickly. It uses [Polars](https://pola.rs/) for fast local data operations and provides drill-down analytics by merchant, category, or time period. All filtering, searching, and aggregation happens locally, with no API latency after the initial data download. It is the kind of tool that scratches a very particular itch, the sort of thing that a certain class of technically minded person has always wished existed, and Wes simply went ahead and built it.

While moneyflow was a tool coded using AI, Wes's next three tools appear aimed at improving his process of coding with AI: essentially building the ship while sailing it.

### `agent-session-viewer`, or, Making Sense of the Conversation Trail

As anyone who works extensively with AI coding agents knows, the sessions pile up with remarkable speed, and finding that one conversation where a particular problem was solved or a specific approach was discussed can become an exercise in frustration.

![The agent-session-viewer web interface for browsing and searching AI coding sessions.](images/agent-session-viewer.png){fig-alt="agent-session-viewer showing a web UI with a list of AI coding sessions and a conversation view"}

[`agent-session-viewer`](https://github.com/wesm/agent-session-viewer) addresses this directly, providing a web-based interface for browsing, searching, and revisiting sessions from Claude Code and Codex. It features full-text search across all sessions, live updates as active sessions progress, automatic background syncing, and the ability to export sessions as self-contained HTML documents or publish them as GitHub Gists for sharing with colleagues. It is written primarily in Python with a [Tauri](https://tauri.app/)-based native app component in Rust.

With the session logs under control, the next natural question was: how much is all of this costing?

### VibePulse (Watching the Token Meter)

![VibePulse menu bar views showing daily cumulative spend and 30-day usage breakdown.](images/vibepulse-today.png){fig-alt="VibePulse macOS menu bar app showing a daily summary of Claude Code and Codex token consumption"}

[VibePulse](https://github.com/wesm/vibepulse) is a macOS menu bar application, written in Swift, that monitors Claude Code and Codex token consumption. It provides a daily cumulative spend view and a 30-day view with per-tool breakdowns, helping heavy users of AI coding agents keep an eye on how much computational resources they are actually consuming. It is a small but practical utility, the sort of thing one builds when one is using these tools so intensively that tracking the usage itself becomes a necessity.

With visibility into sessions and spend, the remaining bottleneck was code quality: reviewing the ever-growing stream of agent-generated commits.

### roborev, Continuous Code Review for Agents

![The roborev TUI showing the review queue with commit reviews, verdicts, and status.](images/roborev.png){fig-alt="roborev terminal UI displaying the review queue screen with commit reviews and their pass/fail verdicts"}

Perhaps the biggest of his recent projects is [roborev](https://roborev.io/) ([GitHub](https://github.com/roborev-dev/roborev)), a continuous background code review system written in Go. The premise is elegantly simple and addresses a real problem in the emerging world of agentic software development. AI coding agents write code quickly, but they make mistakes, and under the old workflow the review of that code would come far too late to be useful, often after the agent had already moved on to the next task and the relevant context was lost.

roborev solves this by reviewing every commit as it happens. It installs as a post-commit hook, runs reviews in the background, and surfaces issues in seconds rather than hours. It comes with an interactive terminal interface, supports multiple agents including Codex, Claude Code, Gemini, Copilot, and others, and can even automatically fix the issues it finds through its `roborev fix` and `roborev refine` commands. The project has already reached version `0.26.0` with 55 releases, and it has attracted an engaged community of contributors. Wes himself has said that roborev has "totally transformed" his productivity, and one can easily see why: it closes the feedback loop on agent-generated code to something approaching real time.

With the full productivity stack in place (session viewer, token monitor, code reviewer), Wes had essentially fired up the full machine. His final project marks a full embrace of the agentic coding in Go lifestyle. (For more, see his post on [agent ergonomics](https://wesmckinney.com/blog/agent-ergonomics/).)

### msgvault: Archive a Lifetime of Email

![The msgvault interactive TUI showing aggregated email senders with message counts and sizes.](images/msgvault-tui.svg){fig-alt="msgvault terminal UI displaying a list of email senders aggregated by message count and total size"}

[msgvault](https://msgvault.io/) ([GitHub](https://github.com/wesm/msgvault)) is a tool for archiving and searching a lifetime of email and chat messages, written in Go and powered by DuckDB for fast analytics over Parquet files. It performs a full Gmail backup including raw MIME data, attachments, labels, and metadata, and then provides a rich interactive terminal interface for exploring the archive. It features full-text search with Gmail-like query syntax, incremental sync via the Gmail History API, multi-account support, and content-addressed attachment deduplication. Perhaps most notably, it includes an MCP server so that AI assistants can search and analyze your full message history conversationally. The project has already gathered nearly a thousand stars on GitHub and has a growing community on Discord.

## What Stands Out

A few things about Wes's approach are worth highlighting. First, he's fearless about working in unfamiliar languages. His career was built on Python, but most of these projects are in Go, Swift, and Rust. He chose Go for roborev and msgvault not because he knew it, but because it produces distributable static binaries, builds fast, and performs well. AI agents bridged the gap between his intent and the implementation.

Second, he's optimized everything around the agentic workflow (fast compile-and-test cycles, self-contained binaries, and automated code review on every commit). Minimizing friction in that loop matters a lot when agents are compiling and testing far more frequently than any person would.

And third, this was all done on nights and weekends and was driven by enthusiasm. These are practical tools that solve real problems, produced by a single person working alongside AI agents over just a few months.

## My Takeaways

Watching Wes's journey over these past few months has genuinely changed how I think about my own work. Here's what I'm carrying forward:

**Leverage AI Agents:** Individual engineers with the right combination of experience, taste, and ambition can now accomplish what once required entire teams. AI coding agents provide real leverage, especially for those with a clear vision and strong engineering judgment.

**Just Build:** If you have an idea for a tool that would make your life or others' lives better, the barriers to building it have never been lower. Don't let unfamiliar languages or ambitious scope stop you. Meaningful progress is possible even in off hours.

**Share Your Methods:** Wes's openness in sharing his methods and insights is a model for the community. Experience, paired with powerful new tools, can unlock remarkable productivity and creativity.

As someone who maintains open source packages for a living, I've already started applying these lessons! I'm leaning on agents more, I worry a bit less about whether I know a language before reaching for it, and I've been building small tools I'd previously only daydreamed about. If Wes's example is any indication, the best reason to start is that it's just a lot of fun.
